# TCP 흐름제어

TCP 연결의 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정한다고 앞에서 배웠다.  
TCP 연셜이 순서대로 올바르게 바이트를 수신할 때 TCP는 데이터를 수신 버퍼에 저장한다.  

해당 애플리케이션 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에 읽을 필요는 없다.  
사실 수신하는 애플리케이션은 다른 작없으로 바쁠 것이고 오랜 시간 동안 데이터를 읽지 않을 것이다.  

애플리케이션이 데이터를 읽는 속도가 비교적 느리다면, 송신자가 점점 더 많은 데이터를 빠르게 전송함으로써 연결 수신 버퍼에 아주 쉽게 오버플로를 발생시킨다.  
이처럼 TCP는 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 애플리케이션에게 흐름제어 서비스를 제공한다.  

수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다.  

TCP는 송신자가 수신자의 수신윈도라는 변수를 유지하여 흐름제어를 제공한다.  
수신 윈도는 수신측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주는데 사용된다.  

TCP는 전이중 연결이므로 연결의 각 측의 송신자는 별개의 수신윈도를 유지한다.  
TCP 연결상에서 호스트 A가 호스트 B에게 큰 파일을 전송한다고 가정할 때, 호스트 B는 이 연결에 수신 버퍼를 할당한다.  

이 때 할당된 수신 버퍼의 크기를 RcvBuffer라고 명명한다.  
시간나는 대로 호스트 B의 애플리케이션 프로세스는 버퍼로부터 데이터를 읽으며 다음과 같은 변수를 정의한다.  

LastByteRead: 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 번호  
LastByteRcvd: 호스트 B에서 네트워크로부터 도착하여 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 번호  

TCP는 할당된 버퍼의 오버플로를 허용하지 않으므로 다음 수식이 가능하다.  
$LastByteRcvd-LastByteRead<=RcvBuffer$  
rwnd로 명명된 수신 윈도는 버퍼의 여유공간으로 설정된다.  
$rwnd=RcvBuffer-(LastByteRcvd-LastByteRead)$  

시간에 따라 여유공간은 변하므로 rwnd는 동적이다.  

호스트 B는 호스트 B가 호스트 A에게 전송하는 모든 세그먼트의 윈도 필드에 현재 rwnd 값을 설정함으로써 연결 버퍼에 얼만큼의 여유공간이 잇는지를 호스트 A에게 알려준다.  
초기에는 호스트 B는 몇 개의 특정 연결 관련 변수들을 유지해야 함을 유의하라.  

반면에 호스트 A는 명백한 의미가 있는 두 변수 LastByteSent와 LastByteAckeed를 유지한다.  
이 두 변수의 차이(LastByteSent-LastByteAcked)는 호스트 A가 이 연결에 전송확인응답이 안된 데이터의 양이다.   

rwnd보다 작은 확인응답 안된 데이터의 양을 유지함으로써 호스트 A는 호스트 B의 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다.  
이와같이 호스트 A는 연결된 동안 다음 내용을 보장한다.  
$LastByteSent-LastByteAcked<=rwnd$  

이 방식에는 사소한 문제점이 있다.  
호스트 B의 수신버퍼는 rwnd=0으로써 가득 찼다고 가정하자.  
호스트 A에게 rwnd=0이라고 알린 후에 호스트 B는 호스트 A에게 전송할게 없다고 가정하자.  

호스트 B에서의 애플리케이션 프로세스가 버퍼를 비우더라도 TCP는 호스트 A에게 새로운 rwnd로 새로운 세그먼트를 전송하지 않는다.  
즉, TCP는 전송할 데이터가 있거나 전송해야할 확인응답을 가진 경우에만 호스트 A에게 세그먼트를 전송할 것이기 때문에, 호스트 A는 호스트 B의 수신버퍼에 약간의 공간이 있다는 것을 모른다.  
호스트 A는 차단되고 더는 데이터를 전송할 수가 없다.  

이러한 문제를 해결하기 위해 TCP 명세서는 호스트 A가 호스트 B의 수신윈도가 0일 때 1바이트 데이터로 세그먼트를 계속해서 전송하도록 요구한다.  
이 세그먼트들은 수신자에 의해 긍정확인응답될 것이다.  
결과적으로 버퍼가 비워지고 긍정확인응답은 0이 아닌 rwnd값을 포함한다.  

## 정리 및 요약  

TCP에서는 흐름제어를 제공한다.  
흐름제어란 수신자의 애플리케이션이 수신버퍼에서 데이터를 읽는 속도가 송신자로부터 데이터를 받는 속도보다 느리다면 수신버퍼는 오버플로될 것이다.  

따라서 송신자는 수신자의 수신버퍼의 여유공간인 수신윈도보다 작거나 같은 확인응답 안된 패킷을 유지함으로써 수신자의 수신버퍼가 오버플로되지 않게 만드는 것이다.  

rwnd가 0이되고 수신자가 송신자에게 보낼 데이터가 없다면, 서로의 연결이 차단되기 때문에 송신자는 1바이트 데이터를 계속 보냄으로써 수신자의 수신윈도가 비워졌을 때, 송신자에게 확인응답으로 알릴 수 있도록 한다.  






