# 비연결형 트랜스포트 계층 프로토콜 : UDP

적어도 트랜스포트 계층은 네트워크 계층과 해당하는 애플리케이션 레벨 프로세스간의 데이터를 넘겨주기 위해 다중화와 역다중화 서비스를 제공해야 한다.  

UDP는 다중화와 역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.  
UDP는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드셰이크를 사용하지 않는 비연결형이다.  

DNS는 UDP를 사용하는 예시이다. 호스트 DNS애플리케이션이 질의를 생성할 때 DNS 질의 메시지를 작성하고 UDP에게 메시지를 넘겨준다.  

목적지 종단 시스템에서 동작하는 UDP 개체와 호스트측 UDP는 어떠한 핸드셰이크도 수행하지 않고 메시지에 헤더 필드를 추가한 후 최종 세그먼트를 네트워크 계층에 넘겨준다.  

네트워크 계층은 UDP 세그먼트를 데이터그램으로 캡슐화하고 네임서버에 데이터그램을 송신한다.  

이 때 질의 호스트에서의 DNS 애플리케이션은 질의에 대한 응답을 기다린다.  

만약 질의 호스트가 응답을 수신하지 못한다면 질의를 다른 네임서버로 송신하거나 이를 야기한 애플리케이션에게 응답을 수신할 수 없음을 통보한다.  

TCP는 신뢰적인 데이터 전송 서비스를 제공하지만 UDP는 그렇지 않으므로 TCP가 항상 더 선호될까?  
그렇지 않다. 왜냐하면 많은 애플리케이션은 다음과 같은 이유로 UDP에 더 적합하다.  

1. 무슨 데이터에 대해 애플리케이션 레벨에서 더 정교한 제어
   - UDP는 데이터를 UDP 세그먼트로 만들고 그 세그먼트를 즉시 네트워크 계층으로 전달한다.
   - 이에 반해서 TCP는 혼잡제어 매커니즘을 가지고 있다. 하나 이상의 링크가 과도하게 혼잡해지면, 트랜스포트 계층 TCP 송신자를 제한한다.  
   - 또한 TCP는 신뢰적인 전달이 얼마나 오래 걸리는지에 관계 없이 목적지가 세그먼트의 수신 여부를 확인응답할 때 까지 데이터의 세그먼트 재전송을 계속할 것이다.  
   - 실시간 애플리케이션은 최소 전송률을 요구할 때도 있고, 지나치게 지연되는 세그먼트의 전송을 원하지 않으며, 조금의 데이터 손실은 허용할 수 있으므로, TCP의 서비스 모델은 이러한 애플리케이션의 요구와는 맞지 않다.  
   - 이러한 애플리케이션은 UDP를 사용하고, 애플리케이션의 한 부분으로서 UDP의 기본 세그먼트 전달 외에 필요한 어떤 추가 기능을 구현할 수 있다.  
2. 연결설정이 없다.
   - TCP는 데이터 전송을 시작하기전에 세 방향 핸드셰이크를 사용한다.
   - 반면에 UDP는 공식적인 사전준비 없이 전송한다.
   - 크롬 브라우저에서 사용되는 QUIC(Quick UDP Internet Connection)프로토콜은 기본 트랜스포트 프로토콜로 UDP를 사용하고 UDP위에 애플리케이션 계층 프로토콜의 안정성을 추가한다.
3. 연결 상태가 없다.
   - TCP는 종단 시스템에서 연결 상태를 유지한다.
   - 이에 반하여 UDP는 연결상태를 유지하지 않는다.
4. 작은 패킷 오버헤드
   - TCP는 세그먼트마다 20바이트의 오버헤드를 갖지만 UDP는 단지 8바이트 오버헤드를 갖는다.  


신뢰적인 데이터 전송이 애플리케이션의 성능에 절대적으로 중요한 것만은 아니다.  

게다가 인터넷 전화와 화상 회의같은 실시간 애플리케이션들은 TCP 혼잡제어가 나쁜 영향을 미친다. 그래서 개발자들은 이 경우 UDP에서 동작하도록 구현한다.  

오늘날 멀티미디어 애플리케이션을 UDP위에서 동작시키는 방법이 일반적으로 사용되지만 아직 논의의 여지가 있다.  

UDP는 혼잡제어를 제공하지 않는다.  
그러나 혼잡 제어는 네트워크가 꼭 필요한 작업을 할 수 없게 되는 폭주 상태에 빠지는 것을 막기 위해 반드시 필요하다.  

만약 모두가 혼잡 제어를 사용하지 않고 높은 비트의 비디오 스트리밍을 시작한다면, 라우터에 많은 오버플로가 발생할 것이고, 이는 소수의 UDP 패킷만이 출발지-목적지 간의 경로를 무사히 통과할 것이다.  

또한 제어되지 않은 UDP 송신자에 의해 발생한 높은 손실률은 그 손실률을 감소시키기 위해 TCP 송신자들이 속도를 줄이도록할 것이다.  

그러므로 UDP의 혼잡제어 결여는 UDP 송신자와 수신자 간의 높은 소실률을 초래할 수도 있고, TCP 세션의 혼잡이 발생할 수 있으며 이는 잠재적으로 심각한 문제점이다.  

UDP를 사용할 때도 신뢰적인 데이터 전송이 가능하다는 것에 주목하자.  
만약 애플리케이션이 신뢰적을 애플리케이션 자체에서 제공한다면 신뢰적인 데이터 전송이 가능하다.  

QUIC 프로토콜은 UDP상에서 애플리케이션 계층에 신뢰성을 구현했다고 언급했다.  

신뢰성을 애플리케이션에 직접 포함하는 것은 애플리케이션이 '동시에 두 마리 토끼를 잡는 격'이다.  

즉, 애플리케이션 프로세스들은 TCP의 혼잡제어 매커니즘에 의해 전송률 억제를 강요당하지 않고도 신뢰적으로 통신할 수 있다.  

## UDP 세그먼트 구조


| 16비트                   | 16비트          |
|:------------------------: | :---------------: |
| 출발지 포트번호          | 목적지 포트번호 |
| 길이                     | 체크섬          |
| 애플리케이션 계층 메시지 | 애플리케이션 계층 메시지 |

애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치한다.  

UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다.  

출발지 포트번호, 목적지 포트번호를 가지며 목적지 호스트가 목적지 종단 시스템에서 동작하는 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해준다.  

체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다.  

길이 필드는 헤더를 포함하는 UDP 세그먼트의 길이(바이트 단위)를 나타낸다.  


## UDP 체크섬  

UDP 체크섬은 오류 검출을 위한 것이다.  
즉, 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때, UDP 세그먼트안의 비트에 대한 변경사항이 있는지 검사하는 것이다.  

송신자 측에서 UDP는 세그먼트 안에 있는 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로는 윤회식 자리올림을 한다.  

이 결괏값이 UDP 세그먼트의 체크섬 필드에 삽입된다.  

예시를 들어보자.  

| 아래의 3개의 16비트 워드가 있다고 가정하자 |
| :----------------------------------------: |
|              0110011001100000              |
|              0101010101010101              |
|              1000111100001100              |

| 처음 두개의 워드 합은 다음과 같다. |
| :--------------------------------: |
|          0110011001100000          |
|          0101010101010101          |
|          1011101110110101          |

| 세 번째 워드를 더하면 다음과 같은 결과가 나온다. |
| :----------------------------------------------: |
|                 1011101110110101                 |
|                 1000111100001100                 |
|                1 0100101011000001                |
|                 0100101011000010                 |


마지막 합은 오버플로가 있고 이를 윤회식 자리올림을 했음에 유의하자.  

1의 보수는 모든 0을 1로 변환하고 모든 1을 0으로 변환하면 구할 수 있다.  

그래서 합의 1의 보수는 1011010100111101이고 이것이 체크섬이 된다.  

수신자에서는 체크섬을 포함한 4개의 모든 비트의 16비트 워드들이 더해진다. 만약 패킷에 어떤 오류도 없다면, 수신자에서의 합은 1111111111111111이 될 것이다.  

만약 비트들 중에 하나라도 0이 있다면 패킷에 오류가 발생했음을 알 수 있다.  

링크 계층 프로토콜이 오류 검사를 제공하는데 왜 UDP가 체크섬을 제공하는지 궁금할 것이다.  
그 이유는 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없기 때문이다.  

그러므로 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수 있다.  
주어진 링크간의 신뢰성과 메모리의 오류 검사가 보장되지도 않고 종단 간의 데이터 전송 서비스가 오류 검사를 제공해야 한다면, UDP는 종단 기반으로 트랜스포트 계층에서 오류 검사를 제공해야만 한다.  
이것이 시스템 설계에서 그 유명한 **종단과 종단의 원칙**의 예시이다.  

즉, 어떤 기능이 종단 기반으로 구현되어야 하므로, '하위레벨에 있는 기능들은 상위 레벨에서 이들을 제공하는 비용과 비교했을 때 중복되거나 거의 가치가 없을 수 있다는' 것이다.  

UDP는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떤 일도 하지 않는다.  

일부 UDP 구현에서는 손상된 세그먼트를 그냥 버리기도 하고, 다른 구현에서는 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 한다.  


