# 신뢰적인 데이터 전송 프로토콜의 구축

## 완벽하게 신뢰적이 채널상에서의 신뢰적인 데이터 전송: rdt1.0

> 하위 채널이 완전히 신뢰적인 가장 간단한 경우를 고려한다.  

rdt 송신측은 rdt_send(data) 이벤트에 의해 상위 계층으로부터 데이터를 받아들이고 데이터를 포함한 패킷을 생성한다.(make_pkt) 그리고 난 후 패킷을 채널로 송신한다.(udt_send)  

수신측에서 rdt는 rdt_rct(packet) 이벤트에 의해 하위의 채널로부터 패킷을 수신하고, 패킷으로부터 데이터를 추출(extract)한 후 데이터를 상위 계층으로 전달한다.(deliver_data)  

> 완전히 신뢰적인 채널에서는 오류가 생길 수 없으므로 수신측이 송신측에게 어떤 피드백도 제공할 필요가 없다.  


## 비트 오류가 있는 채널상에서의 신뢰적인 데이터 전송: rdt2.0

> 하위 채널의 더 실질 모델은 패킷 안의 비트들이 하위 채널에서 손상되는 모델이다.  
> 그러한 비트 오류는 패킷이 전송 또는 전파되거나 버퍼링될 때 네트워크의 물리적 구성요소에서 일반적으로 발생한다.  
> 다만, 전송된 모든 패킷이 송신된 순서대로 수신된다고 가정하자.  

컴퓨터 네트워크 설정에서 그러한 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 자동 재전송 요구 프로토콜로 알려져 있다. (Automatic Repeat reQuest, ARQ)  

비트 오류를 처리하기 위해 기본적으로 다음과 같은 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다.  

1. 오류검출 
   - 첫빼, 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다.
2. 수신자 피드백  
   - 송신자와 수신자가 일반적으로 수천 킬로미터 떨어진 각기 다른 종단 시스템에서 동작하므로, 송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백을 제공하는 것이다.  
   - rdt2.0은 수신자로부터 송신자쪽으로 ACK와 NAK패킷들을 전송할 것이다. 이러한 패킷은 한 비트이면 된다.  
3. 재전송
   - 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다.

왼쪽 상태에서 송신측 프로토콜은 상위 계층으로부터 데이터가 전달되기를 기다린다. rdt_send() 이벤트가 발생하면 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(sndpkt)를 생성하고 그 패킷을 udt_send 동작을 통해 전송할 것이다.  

오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK 또는 NAK 패킷을 기다린다. 만약 ACK 패킷이 수신된다면 송신자는 가장 최근에 전송한 패킷이 정확하게 수신되었음을 알게된다.(rdt_rcv() && isACK())  
그래서 프로토콜은 상위 계층으로 데이터를 기다리는 상태로 돌아간다.  
만약 NAK가 수신되면 프로토콜은 마지막 패킷을 재전송하고 재전송된 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK와 NAK를 기다린다.  

송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때, 상위 계층으로부터 더 이상의 데이터를 전달받을 수 없다는 점에 유의하라 즉, rdt_send() 이벤트는 발생할 수 없다.  

이러한 행동 때문에 rdt2.0과 같은 프로토콜은 전송 후 대기 프로토콜로 알려져 있다. (하나의 메시지를 완벽히 보내기까지 계속 재전송)  

rdt2.0 프로토콜은 잘 작동하는 것 같지만 실제로는 치명적인 결함이 있다. 여기서는 ACK 또는 NAK 패킷이 손상될 수 있다는 가능성을 고려하지 않았다.  
최소한 그러한 오류를 검출하기 위해 ACK와 NAK 패킷에 대한 체크섬 비트를 추가할 필요가 있다.  

어떻게 ACK와 NAK 패킷 오류로부터 복구되는 것일까?  
여기서 더 어려운 점은 만야 ACK와 NAK가 손상된다면 송신자는 수신자가 전송된 데이터의  마지막 부분을 올바르게 수신했는지를 알 방법이 없다.  

손상된 ACK 또는 NAK를 처리하기 위한 세 가지 가능성을 고려해보자.  
1. 첫 번재 가능성으로는 만약 말하는 사람이 수신자로부터의 'OK'또는 '그것을 반복해주세요'라는 응답을 이해하지 못했다면 그 말하는 사람은 아마 '뭐라고 하셨죠?' 라는 질문을 할 것이다. 수신자는 또 그 응답을 반복할 것이다. 그러나 만약 말하는 사람의 '뭐라고 하셨죠'가 손상된다면? 왜곡된 문장이 명령의 일부인지 아니면 마지막 응답을 반복하기 위한 요청인지를 모르는 수신자는 아마 '뭐라고 하셨죠?'라는 응답을 할 것이고 또 다시 이 응답이 왜곡된다면 확실히 어려운 길로 빠지게 된다.  
2. 두 번재 대안은 송신자가 검출 뿐만 아니라 비트 오류로부터 회복할 수 있도록 충분한 체크섬 비트들을 추가하는 것이다. 이 방식은 패킷이 손상될 순 있으나 손실되지 않는 채널의 경우에는 즉각적으로 문제를 해결할 수 있다.  
3. 세 번째 접근은 송신자가 왜곡된 ACK 또는 NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신하는 것이다. 그러나 이 방식은 중복 패킷(Duplicate packet)을 전송하고 마지막으로 전송된 ACK 또는 NAK가 송신자에게 정확하게 수신되었는지 알 수 없다. 그러므로 도착하는 패킷이 새로운 데이터인지 재전송인지를 알 수 없다.  

간단한 해결책은 순서번호를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙이는 것이다.  
따라서 수신자는 패킷이 재전송인지를 결정할 때 이 순서번호만 확인하면 된다.  

간단한 전송 후 대기 프로토콜의 경우 한 비트 순서번호면 송신자가 이전에 전송된 패킷을 전송한 것인지 아니면 새로운 패킷인지 (순서 번호가 변하면 모듈로 2연산을 진행)을 전송한 것인지를 충분히 알 수 있다.  

패킷을 손실하지 않는 채널을 가정하므로 ACK와 NAK패킷은 순서번호를 나타낼 필요가 없다.  

rdt2.1은 수신자로부터 송신자까지의 긍정확인응답과 부정확인응답을 모두 포함한다. 순서가 바뀐 패킷이 수신되면 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답을 전송한다.  

NAK를 송신하는 것 대신에 가장 최근에 정확하게 수신된 패킷에 대한 ACK를 송신함으로써 NAK를 송신한 것과 같은 효과를 얻을 수 있다.  

rdt2.1과 rdt2.2의 미묘한 차이는 수신자가 반드시 ACK 메시지에 의해 응답되는 패킷의 순서번호를 포함해야한다는 점이다. 그리고 송신자는 수신된 ACK 메시지에 의해 확인응답된 패킷의 순서 번호를 반드시 검사해야한다.  


## 비트오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0

> 비트가 손상되는 것 외에도 인터넷을 포함하는 오늘날의 컴퓨터 네트워크처럼 하위 채널이 패킷을 손실하는 경우를 생각해보자.


다음과 같은 두 가지 부가 내용을 프로토콜이 다루어야 한다.  
1. 어떻게 패킷 손실을 검출할 것인가?
2. 패킷 손실이 발생했을 때 어떤 행동을 할 것인가?

체크섬, 순서번호, ACK패킷, 재전송의 사용으로 후자의 관심사에 대해 답할 수 있다.  
첫 번째 관심사를 해결하려면 새로운 매커니즘을 추가해야 한다.  

여기서는 송신자에게 손실된 패킷의 검출과 회복 책임을 부여할 것이다. 송신자가 데이터 패킷을 전송하고 패킷 또는 수신자의 패킷에 대한 ACK를 손실했다고 가정하자.  
어느 경우에서나 송신자에게는 수신자로부터 어떠한 응답도 없다.  

만약 송신자가 패킷을 잃어버렸다고 확신할 정도로 충분한 시간을 기다릴 수만 있다면, 데이터 패킷은 간단하게 재전송될 수 있다.  

그러나 송신자가 어떤 패킷을 손실했다는 것을 확신하기 위해 얼마나 오랫동안 기다려야 할까?  
송신자는 적어도 송신자와 수신자 사이의 왕복 시간 지연에 수신측에서 패킷을 처리하는데 필요한 시간을 더한만큼 기다린다.  

만일 ACK가 이 시간안에 수신되지 않는다면 패킷은 재전송된다. 패킷이 긴 지연을 갖는다면 패킷이나 ACK가 손실되지는 않더라도 패킷을 재전송할 수 있다.  
즉, 중복데이터 패킷의 가능성을 포함한다.  

송신자는 데이터 패킷이 손실되었는지 ACK가 손실되었는지, 패킷 또는 ACK가 지나치게 지연된 것인지 알지 못하지만 이 모든 경우에 행동은 같다. (재전송)  

시간 기반의 재전송 매커니즘을 구현하기 위해, 주어진 시간이 지난 후에 송신자를 인터럽트(중단)할 수 잇는 카운트다운 타이머가 필요하다 그러므로 송신자는 다음 동작을 진행해야된다.  

1. 매 패캐싱 송신된 시간에 타이머를 시작한다.
2. 타이머 인터럽트에 반응한다.
3. 타이머를 멈춘다.

패킷의 순서번호가 0과 1이 번갈아 일어나는 프로토콜 rdt3.0은 때때로 얼터네이팅 비트 프로토콜이라고 부른다.  

## 파이프라이닝된 신뢰적 데이터 전송 프로토콜

rdt3.0 프로토콜은 기능적으로는 정확한 프로토콜이다. 그러나 오늘날의 고속 네트워크에서 누구나 이것의 성능에 만족하는 것은 아니다.  
rdt3.0의 핵심적인 성능 문제는 rdt3.0이 전송 후 대기 프로토콜이라는 점이다.  

두 종단 시스템 사이의 광속 왕복 전파 지연(RTT)은 대략 30ms이다. 이 두 호스트가 1Gbps 전송률(R)을 가진 채널로 연결되어 있다고 가정하자. 헤더 필드와 데이터를 모두 포함하여, 패킷당 1000바이트(8000비트)의 패킷크기(L)를 가지고 1Gbps 링크로 패킷을 실제로 보내는 시간은 다음과 같다.  

> $d = {L\over R} = {8000bit\over10^9bps} = 8μs$

이제 패킷은 $t= {RTT\over2} + {L\over R} = 15.008ms$에 수신측으로 마지막 비트가 수신된다.  
송신측에 ACK 패킷은 $t= RTT + {L\over R} = 30.008ms$ 후에 다시 받을 수 있다.  

그러므로 30.008ms 동안 송신자는 단지 0.008ms 동안만 데이터를 전송한 셈이다. 실제로 분주하게 비트를 전송하는데만 걸린 시간을 송신자의 이용율 수식으로 정의한다면, 전송 후 대기 프로토콜이 형편없는 송신자 이용률을 갖는다는 것을 보여준다.  

> $ U = {L\over R} \over {RTT + {L \over R}} = 0.00027 $

즉, 송신자는 단지 시간의 0.0027% 만큼만 바빳다. 송신자는 30.008ms 동안 1000바이트를 전송할 수 있지만, 비록 초당 1Gbps의 링크가 가용하다고 하더라도 267kbps의 유효 처리량을 갖는다.  

이런 문제는 간단한 해결책이 있다.  
확인응답을 기다리지 않고 여러 패킷의 전송을 허용하는 것이다.  
확인응답을 기다리기 전에 송신자가 3개의 패킷을 전송하도록 허용한다면 송신자의 이용률은 3배가 되라라는 것을 보여준다.  

많은 전송중인 송신자-수신자 패킷을 파이프라인에 채워 넣음으로써 나타낼 수 있다. 이 기술을 파이프라이닝이라고 부른다.  

파이프라이닝 방식은 신뢰적인 데이터 전송 프로토콜에서 다음과 같은 중요성을 지니고 있다.  

1. 순서번호의 범위가 커져야한다. 패킷들은 유일한 순서번호를 가져야 하고 전송중인 확인응답 안된 패킷이 여러개 있을지도 모르기 때문이다.  
2. 프로토콜의 송신측과 수신측은 패킷 하나 이상을 버퍼링해야된다. 최소한 송신자는 전송되었으나 확인응답 되지 않은 패킷을 버퍼링해야된다. 정확하게 수신된 패킷의 버퍼링은 다음에 설명한 것처럼 수신자도 필요하다.  
3. 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜의 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려있다.  

파이프라인 오류 회복의 두 가지 접근방법으로는 GBN(Go-Back-N)과 SR(Selective Repeat) 등이 있다.  


## 정리 및 요약

신뢰적 데이터 전송 서비스를 알아보기 위해 점점 복잡해지는 네트워크에 대해서 알아보았다.  

먼저 rdt1.0은 신뢰적인 하위채널의 경우를 고려하기 때문에 별다른 조치를 취하지 않고 애플리케이션 계층 메시지를 캡슐화하여 네트워크 계층으로 보내고 수신자는 패킷에서 메시지를 추출하여 애플리케이션 계층으로 전달한다.  

rdt2.0은 비트오류가 있는 채널의 경우를 고려하며 손실은 일어나지 않고 데이터가 모두 순서대로 전송된다.  

이러한 해결책으로는 송신자가 보내는 패킷에 체크섬을 추가하고 수신자는 패킷을 받았을 때 ACK 또는 NAK로 패킷의 손상을 송신자에게 피드백한다.  
이 피드백을 이용하여 송신자는 피드백을 받았을 때 재전송할지 아니면 다음 데이터를 기다리는 상태가 될지를 결정한다.  

또한 rdt 프로토콜은 전송 후 대기 프로토콜이기 때문에 ACK 또는 NAK 패킷의 수신을 기다리고 있다면 송신자는 상위 계층으로부터 데이터를 받을 수 없다.  

rdt2.1은 ACK 또는 NAK 패킷의 손상을 고려하지 않는 문제점을 해결했다.  
이러한 문제점은 ACK와 NAK 패킷에 체크섬을 추가하고 순서 번호를 추가함으로써 송신자가 보낸 패킷이 재전송인지 아니면 다음 패킷인지를 구분하도록 하였다.  

따라서 수신자는 ACK 또는 NAK 패킷이 손상된 결과로 온 이전 패킷에 대한 재전송을 구분하여 ACK 패킷을 재전송만 하면된다.  

rdt2.2는 NAK 패킷을 사용하지 않는 대신 이전 패킷에 대한 ACK를 통해 NAK를 사용한 것과 같은 효과를 볼 수 있다.  

수신자는 ACK 패킷에 순서번호를 넣고 송신자는 ACK 패킷을 받았을 때 순서번호만 확인하면 된다.  

rdt3.0은 하위 채널이 비트오류 뿐만아니라 손실까지 발생하는 채널이다.  

이러한 채널은 송신된 패킷에 대한 손실 검출과 손실에 대한 대응만 해주어야 한다.  
손실에 대한 대응은 확인응답, 재전송, 순서번호, 체크섬을 통하여 해결되었다.  

따라서 손실 검출을 해결해야 한다. 이런 해결책은 간단히 타임아웃 기능을 넣어줌으로써 해결하였다.  

따라서 송신자가 패킷을 송신하고 RTT+조금의 시간 이 지났을 때 패킷의 손상임을 감지하고 재전송한다.  

rdt 프로토콜은 완벽한 것 같지만 전송 후 대기 프로토콜이기 때문에 매우 낮은 이용률을 보여준다.  
따라서 한번에 여러개의 전송을 통해 파이프라이닝 해주어야 한다.  

파이프라이닝을 해주기 위해서는 송신자에게 송신 버퍼를 할당해주어야하고 각각의 확인응답되지 않은 패킷에 순서번호를 붙여야되기 때문에 순서번호가 커져야 할 것이다.  

또한 수신자에대한 버퍼는 GBN 프로토콜인지 SR 프로토콜인지에 따라 달라지게 된다.  










