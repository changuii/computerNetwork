# TCP:신뢰적인 데이터 전송

TCP는 IP의 비신뢰적인 최선형 서비스에서 신뢰적인 데이터 전송 서비스를 제공한다.  
TCP의 신뢰적인 데이터 전송 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으며 손실이나 중복이 없다는 것과 순서가 유지된다는 것을 보장한다.  

다시말해, 바이트 스트림은 송신자가 전송한 것과 같은 바이트 스트림이다.

세그먼트와 개별적인 타이머가 한 쌍이 되어 동작한다고 가정하는 것이 이론상으로는 훌륭할지 몰라도, 타이머 관리는 상당한 오버헤드를 요구한다.  
권장되는 TCP 타이머 관리 절차에서는 오직 단일 재전송 타이머를 사용한다.  

TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트가 있다.  
그것은 상위 애플리케이션으로부터 수신된 데이터, 타이머 타임아웃, ACK수신이다.  

첫 번째 주요 이벤트 발생으로 TCP는 애플리케이션으로부터 데이터를 받고, 세그먼트로 이 데이터를 캡슐화하고 IP에게 세그먼트를 넘긴다.  
각 세그먼트는 첫 번째 데이터 바이트의 바이트 열 번호인 순서번호를 포함한다.  
또한 타이머가 이미 다른 세그먼트에 대해 실행 중이 아니면 TCP는 이 세그먼트를 IP로 넘길 때 타이머를 시작한다.  

두 번째 주요 이벤트는 타임아웃이다. TCP는 타임아웃 이벤트에 대해 타임아웃을 일으킨 세그먼트를 재전송하여 응답한다. 그리고 TCP의 타이머를 다시 시작한다.  

세 번째 주요 이벤트는 수신자로부터의 수신 확인응답 세그먼트의 수신이다.  
이 이벤트가 일어나면, TCP는 변수 sendbase와 ACK값 y를 비교한다.  
TCP 상태 변수 sendbase는 수신확인응답되지 않은 가장 오래된 바이트의 순서번호이다.  
TCP는 누적 확인응답을 사용하고, y는 y바이트 이전의 모든 바이트의 수신을 확인한다.  
만일 y>sendbase 이면, ACK는 이전에 확인응답 안된 하나 이상의 세그먼트들을 확인해준다.  


## 몇 가지 흥미로운 시나리오  

호스트 A가 호스트 B에게 하나의 세그먼트를 보내는 시나리오이다.  
이 세그먼트의 순서번호 92와 8바이트 데이터를 포함한다고 가정하자.  
호스트 A가 이 세그먼트를 전송한 후에 호스트 A는 호스트 B로부터 긍정 확인응답 번호 100을 가진 세그먼트를 기다린다.  

A로부터의 세그먼트가 B측에서 수신되었음에도 B로부터 A로의 긍정 확인응답이 손실된다면 이런 경우에 타임 아웃이 일어나고 호스트 A는 같은 세그먼트를 B에게 재전송한다.  
물론 호스트 B가 재전송 세그먼트를 수신했을 때 이미 수신된 데이터이기 때문에 버릴 것이다.  

두 번째 시나리오는 호스트 A가 연속해서 두 세그먼트를 전송한다.  
첫 번째 세그먼트는 순서번호 92와 8바이트 데이터를 갖고 있고, 두 번째 세그먼트는 순서번호 100과 20바이트 데이터를 갖고 있다.  
두 세그먼트는 모두 호스트 B에 무사히 도착한다고 가정한다면, B는 각각의 세그먼트에 대해 2개의 개별적인 긍정 확인응답을 전달한다.

이러한 긍정 확인응답 중 첫 번째는 긍정확인응답 번호 100을 갖는다.  
반면 두 번째 확인응답은 응답번호 120을 갖는다. 이제 호스트 A에서 차임아웃 이전에 어떠한 긍정 확인응답도 수신하지 못한다고 가정하자  

타임아웃 이벤트가 발생하면, 호스트 A는 순서번호 92로 첫 번째 세그먼트를 재전송하고 타이머를 다시 시작한다.  
새로운 타임아웃 이전에 두 번째 세그먼트에 대한 ACK가 도착한다면 두 번째 세그먼트는 재전송하지 않는다.  

세 번째 마지막 시나리오는 호스트 A가 똑같이 2개의 세그먼트를 전송한다고 가정한다.  
첫 번째 세그먼트의 긍정확인응답이 네트워크에서 분실되었지만 첫 번째 세그먼트의 타임아웃 전에 호스트 A가 긍정확인응답번호 120의 확인응답을 수신한다면, 호스트 A는 호스트 B가 119바이트 까지 모든 데이터를 수신했음을 알게 되고 호스트 A는 어느것도 재전송하지 않는다.  


## 타임아웃 주기의 두배로 설정

이제 대부분의 TCP 구현에서 사용하는 몇 가지 수정사항을 논의해보자 첫 번째 타이머의 종료 후 타임아웃 주기의 길이에 대한 것이다.  
이 수정에서는 타임아웃이 발생할 때마다 TCP는 앞에서 설명한 것처럼 아직 확인응답 안된 가장 작은 순서번호를 가진 세그먼트를 재전송한다.  

그러나 TCP는 재전송 때마다 마지막 EstimatedRTT와 DevRTT로부터 타임아웃 값을 가져오는 것이 아니라 타임아웃 주기를 이전의 두배로 설정한다.  

예를들어 타이머가 만료되었을 때 TimeOutInterval이 0.75초라고 가정한다면 TCP는 세그먼트를 재전송하고 새로운 종료 시간을 1.5초로 한다.  
다시 타임아웃 된다면 3.0초가 된다.  

그러나 다른 두가지 이벤트(상위 애플리케이션으로부터 데이터 수신과 ACK수신) 이후 타이머가 시작될 때 TimeOutInterval은 EstimatedRTT와 DevRTT의 가장 최근 값에서 가져온다.  

이 수정은 제한된 형태의 혼잡 제어를 제공한다.  
타이머 종료는 주로 네트워크에서의 혼잡에 의해 발생한다.  
즉, 출발지와 목적지 사이의 경로에서 하나 이상의 라우터 버퍼에 도착한 많은 패킷은 패킷의 손실이나 큐 대기의 원인이 된다.  

혼잡할 때 출발지에서 지속해서 패킷의 재전송을 고집한다면 그 혼잡은 더욱 악화될 것이다.  
대신에 TCP는 송신자가 더 긴 간격으로 재전송하도록 한다.  

## 빠른 재전송

타임아웃이 유발하는 재전송의 한 가지 문제는 타임아웃의 주기가 때때로 비교적 길다는 것이다.  
세그먼트를 잃었을 때, 긴 타임아웃 주기는 잃어버린 패킷을 다시 보내기 전에 송신자를 오래 기다리게 해서 종단간 지연을 증가시킨다.  

다행히도 송신자는 종종 소위 중복 ACK에 의한 타임아웃이 일어나기 전에 패킷 손실을 발견한다.  
중복 ACK는 송신자가 이미 이전에 받은 확인응답에 대한 재확인응답 세그먼트 ACK이다.  

TCP 수신자가 기다리는 다음 것 보다 더 큰 순서번호를 가진 세그먼트를 받았을 때, TCP 수신자는 그 데이터 스트림에서의 간격(손실 세그먼트)을 찾아낼 것이다.  
수신자는 마지막으로 수신된 순차적인 바이트를 갖는 데이터를 그냥 확인응답(중복 ACK)한다.  

송신자는 종종 많은 양의 세그먼트를 연속적으로 보낼 수 있으므로 만약 하나의 세그먼트를 잃어버린다면, 많은 연속적인 중복 ACK가 존재할 수도 있다.  
3개의 중복 ACK를 수신할 때 TCP는 세그먼트의 타이머가 만료되기 이전에 손실 세그먼트를 재전송하는 빠른 재전송을 한다.  


## GBN인가 SR인가?

TCP가 GBN프로토콜인가 SR프로토콜인가?

TCP의 확인응답은 누적되고 올바르게 수신되지만 순서가 잘못된 세그먼트는 수신자가 개별적으로 ACK를 받지 않는다.  

TCP 송신자는 전송했지만 확인응답 안된 바이트의 가장 작은 순서번호(sendbase)와 전송될 다음 바이트의 순서번호(nextseqnum)를 유지해야 한다.  
이런 관점에서 TCP는 GBN 형태의 프로토콜과 매우 비슷해 보인다.  

그러나 TCP와 GBN은 몇가지 두드러진 차이점이 있다. 많은 TCP 구현에서는 올바르게 수신되었지만 순서가 바뀐 세그먼트들을 버퍼링한다.  
송신자가 세그먼트 1, 2, 3, ... , N을 전송하고 수신측에 오류 없이 순서대로 도달한다고 가정하자.  
그리고 패킷 n<N에 대한 긍정 확인응답이 손실되었지만, 나머지 N-1개의 긍정 확인응답들은 타임아웃 전에 송신측에 도달했다고 가정하자.  

이 예에서 GBN은 패킷 n 뿐만 아니라 연속적인 패킷 n+1, n+2, ...N 모두를 재전송한다.  
반면에 TCP는 기껏해야 세그먼트 n 하나만을 재전송할 것이다.  
더욱이 TCP는 세그먼트 n에 대한 타임아웃 전에 세그먼트 n+1에 대한 긍정 확인응답이 도착한다면 세그먼트를 재전송하지 않는다.  

TCP에서 수정제안된 선택적 확인응답 이라는 것은 TCP 수신자가 마지막으로 올바로 수신된 '순서가 맞는' 세그먼트에 대해 누적확인응답을 하기 보다는 '순서가 틀린' 세그먼트에 대해 선택적으로 확인응답을 하게한다.  

그래서 TCP의 오류 복구 매커니즘은 GBN과 SR 프로토콜의 혼합으로 분류하는 것이 적당하다.  


## 정리 및 요약  

TCP는 IP 위에서 신뢰적인 데이터 전송 서비스를 제공한다.  

TCP는 누적 확인응답을 제공한다.  
따라서 이전의 확인응답안된 패킷들 보다 큰 순서번호를 가진 패킷에 대한 ACK 패킷이 도착한다면 이전의 패킷들은 모두 확인응답된다.  

이는 수신자가 바이트 스트림에서 올바로 순서대로 도착한 패킷의 가장 작은 순서번호의 패킷에 대해서만 확인응답을하기 때문에 가능하다.  

TCP송신자는 타임아웃이 발생하더라도 sendbase의 패킷만을 재전송하기 때문에 GBN과는 다른점이 있고 각각의 패킷에 대해서 수신자가 순서가 맞지 않는 패킷을 버퍼링하기 때문에 SR같은 부분이 있지만 모든 패킷에 대해서 타이머를 가지지 않고 sendbase에 대해서만 타이머를 작동시킨다.  

따라서 TCP는 SR과 GBN프로토콜의 혼합이다.  

TCP는 타임아웃된 패킷에 대해서 TimeOutInterval을 사용하는 것이 아닌 이전 타임아웃 주기의 두배를 사용한다. 이는 혼잡한 네트워크에 송신자를 약간 제어함으로써 혼잡제어를 간접적으로 제공한다.  

TCP는 3개의 중복 ACK패킷이 수신되면 패킷을 타임아웃되기 전에 재전송한다.  


