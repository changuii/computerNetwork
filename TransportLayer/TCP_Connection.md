# TCP 연결 관리


TCP 연결 설정에 느껴지는 지연이 상당히 더해지므로 중요한 주제이다.  
또한 매우 인기있는 SYN 플러드 공격을 비롯한 가장 일반적인 네트워크 공격의 대부분은 TCP 연결관리의 취약점을 악용한다.  

하나의 호스트에서 운영되는 프로세스가 다른 호스트 안의 또 다른 프로세스와 연결을 시작하길 원한다고 가정하자.  
먼저 클라이언트 애플리케이션 프로세스는 서버에 있는 프로세스와 연결 설정하기르 원한다는 것을 클라이언트 TCP에게 알린다.  
그러면 클라이언트안의 TCP는 다음과 같은 방법으로 TCP를 이용해 서버와 TCP 연결 설정을 한다.  

1단계: 먼저 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신한다.  
이 특별한 세그먼트는 애플리케이션 계층 데이터를 포함하지 않는다.  
그러나 세그먼트 헤더에 SYN비트라고 불리는 하나의 플래그비트를 1로 설정한다.  
이러한 이유로 이 특별한 세그먼트를 SYN세그먼트라고 부른다.  

추가로 클라이언트는 최초의 순서번호(Client_isn)를 임의로 선택하고, 최초로 TCP SYN 세그먼트의 순서번호 필드에 이 번호를 넣는다.  
이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신된다.  
특정 보안 공격을 피하고자 Client_isn의 선택을 임의추출하는 것에 유의해야 한다.  

2단계: TCP SYN 세그먼트를 포함하는 IP 데이터그램이 서버에 도착하면 서버는 데이터그램으로부터 TCP SYN 세그먼트를 추출한다. 그리고 연결에 TCP 버퍼와 변수를 할당한다.  
그리고 클라이언트 TCP로 연결승인 세그먼트를 송신한다.  
또한 이 연결 승인 세그먼트도 애플리케이션 계층 데이터를 포함하지 않는다.  
그러나 세그먼트 헤더 안에 3개의 중요한 정보를 포함한다.  

첫째, SYN비트는 1로 설정된다.  
둘째, TCP 세그먼트 헤더의 확인응답 필드는 Client_isn+1로 설정된다.  
마지막으로 서버는 자신의 최초의 순서번호(Server_isn)를 선택하고 TCP 세그먼트 헤더의 순서번호 필드에 이 값을 넣는다.  

이 연결 승인 세그먼트는 사실상 "나는 당신의 최초 순서번호 Client_isn을 가지고 연결을 시작하자는 당신의 SYN패킷을 수신했다. 나는 이 연결 설정에 동의한다. 나 자신의 최초의 순서번호는 Server_isn이다." 라고 말하는 것이다.  
이 연결 승인 세그먼트는 때때로 SYNACK 세그먼트로 불린다.  

3단계 : 연결 승인 세그먼트를 수신하면, 클라이언트는 연결에 버퍼와 변수를 할당한다.  
그 다음에 클라이언트 호스트는 서버로 또 다른 세그먼트를 송신한다.  
이 마지막 세그먼트가 서버의 연결 승인 세그먼트를 확인하는 것이다. (TCP 세그먼트 헤더의 확인응답 필드안에 Server_isn+1 값을 넣는다.)  
연결이 설정되었기 때문에 SYN비트는 0으로 설정된다. 세 방향 핸드셰이크의 세 번째 단계는 클라이언트에서 서버로의 데이터를 세그먼트 페이로드에서 운반할 수 있다.  

일단 위의 세 단계가 완료되면 클라이언트와 서버 호스트들은 각각 서로에게 데이터를 포함하는 세그먼트를 보낼 수 있다.  
연결 설정을 위해 3개의 패킷이 송신되어야하기 때문에 TCP 연결 설정 절차를 세 방향 핸드셰이크라고 부른다.  

제대로된 모든 것에는 끝이 있어야 하고 TCP 연결 또한 이러한 사실이 적용된다.  
TCP연결에 참여하는 두 프로세스 중 하나가 연결을 끊낼 수 있다.  
연결이 끝날 때 '자원'(변수와 버퍼)은 회수된다.  
예를 들어 클라이언트가 연결 종료를 결정한다고 가정하자.  

클라이언트 애플리케이션 프로세스는 종료 명령을 내리고, 이것은 클라이언트 TCP가 서버 프로세스에게 특별한 TCP 세그먼트를 보내도록 한다.  
이 특별한 세그먼트는 1로 설정된 FIN비트라고 불리는 플래그 비트를 세그먼트 헤더에 포함하고 있다.  

서버가 이 세그먼트를 수신하면 서버는 클라이언트에게 확인응답 세그먼트를 보낸다.  
그 다음에 FIN비트가 1로 설정된 자신의 종료 세그먼트를 송신한다.  

마지막으로 클라이언트는 서버의 종료 세그먼트에 확인응답을 한다. 이 시점에서 두 호스트의 모든 자원은 할당이 해제된다.  

TCP 연결이 존재하는 동안 각 호스트에서 동작하는 TCP 프로토콜은 다양한 TCP 상태를 두루 전이한다.  

클라이언트 TCP는 CLOSED 상태에서 시작한다.  
클라이언트 측의 애플리케이션은 새로운 TCP 연결을 시작한다.  
이는 클라이언트의 TCP가 서버의 TCP에게 SYN 세그먼트를 송신하도록 하는 것이다.  

SYN 세그먼트를 송신한 뒤, 클라이언트 TCP는 SYN_SENT 상태로 들어간다.  
SYN_SENT상태에 있는 동안, 클라이언트 TCP는 서버 TCP로 부터 1로 설정된 SYN비트와 클라이언트의 이전 세그먼트에 대한 확인응답을 가진 세그먼트를 기다린다.  

일단 이와 같은 세그먼트를 수신하면, 클라이언트 TCP는 ESTABLISHED(확립된) 상태로 들어간다.  
ESTABLISHED상태에 있는 동안, TCP 클라이언트는 페이로드 데이터를 포함하는 TCP 세그먼트를 송신하고 수신할 수 있다.  

클라이언트 애플리케이션이 연결 종료를 희망한다고 가정하자.  
(또한 서버도 연결 종료를 선택할 수 있다는 것에 주의한다.)  

이것은 클라이언트 TCP가 1로 설정된 FIN비트를 포함하는 TCP 세그먼트를 송신하도록 하고, FIN_WAIT_1 상태로 들어가도록 한다.  
FIN_WAIT_1 상태에 있는 동안, 클라이언트 TCP는 서버로부터 확인응답을 포함하는 TCP 세그먼트를 기다린다.  

이 세그먼트를 수신할 때, 클라이언트 TCP는 FIN_WAIT_2 상태로 들어간다.  
FIN_WAIT_2 상태에 있는 동안, 클라이언트는 서버로부터 1로 설정된 FIN 비트를 포함하는 다른 세그먼트를 기다린다.  

이 세그먼트를 수신하면 클라이언트 TCP는 서버의 세그먼트에 확인응답을 전송하고, TIME_WAIT 상태로 들어간다.  
TIME_WAIT 상태는 TCP 클라이언트의 ACK가 손실되면 마지막 확인응답을 재송신하도록 한다.  
TIME_WAIT 상태에서 소비되는 시간은 구현에의해 달라질 수 있지만 대체로 30초, 1분 또는 2분이다.  

대기시간이 끝나면 연결은 정식으로 종료되고, 클라이언트 측의 (포트번호 포함) 모든 자원이 해제된다.  

호스트가 호스트 내부에서 진행되는 어떤 소켓과 관계없는 포트번호와 출발지 IP주소를 가진 TCP 세그먼트를 수신하면 무슨일이 발생하는지를 고려하자.  
예를들어, 목적지 포트 80을 포함하는 TCP SYN 패킷을 수신하지만, 호스트는 포트 80에서 연결을 수락하지 않고 있다고 가정하자(즉, 포트 80에서 웹 서버로 동작하고 있지 않다.)  

그러면 호스트는 출발지로 특별한 리셋 세그먼트를 보낼 것이다. 이 TCP 세그먼트는 1로 설정한 RST 플래그 비트를 갖는다.  
그러므로 호스트가 리셋 세그먼트를 전송할 때, 출발지에게 '그 세그먼트에 대한 소켓을 가지고 있지 않으니 세그먼트를 재송신하지 말라'고 말하는 것이다.  

호스트가 진행되는 UDP 소켓과 관계없는 목적지 포트 번호를 갖는 UDP 패킷을 수신하면 특별한 ICMP 데이터그램을 전송한다.  

## 정리 및 요약 

TCP 연결설정 절차에대해서 알아보았다.  

클라이언트와 서버가 연결을 설정하고자 한다면  

1. 클라이언트는 SYN비트가 1로설정하고 자신의 최초의 순서번호 Client_isn을 담은 세그먼트를 서버로 송신한다.
2. 서버는 클라이언트의 패킷을 수신하면 SYN비트를 1로 설정하고 자신의 최초의 순서번호 Server_isn과 클라이언트가 보낸 패킷에 대한 확인응답 번호 Cline_isn+1일 담은 세그먼트를 클라이언트로 송신한다. 이 때 서버는 자원을 할당한다.
3. 클라이언트가 이 패킷을 수신하면 자원을 할당하고 SYN비트는 0으로 설정하고 서버에게 받은 패킷에대한 확인응답 번호 Server_isn+1과 페이로드를 채워 패킷을 보낸다.  

이 절차를 통해 클라이언트-서버간에 TCP 연결이 설정된다.  

클라이언트(서버)가 서버(클라이언트)와의 연결을 끊고자(종료하고자) 한다면

1. 클라이언트는 서버로 FIN비트가 1로설정된 세그먼트를 전송한다.  
2. 서버가 패킷을 받았을 때 이 패킷에 대해서 확인응답을 전송하고, FIN비트가 1로 설정된 세그먼트를 송신한다.  
3. 클라이언트가 서버에게 1로 설정된 FIN비트 패킷을 수신하면 확인응답을 보낸다.
4. 서버가 이 세그먼트를 수신하면 비로소 클라이언트와 서버의 자원들의 할당이 해제된다.

만약 서버로 동작하고 있지 않은 소켓에 TCP 연결 요청을 보내면 어떻게될까?  

TCP는 RST비트가 1로 설정된 패킷을 클라이언트에게 돌려준다.  
이 패킷은 해당 소켓이 존재하지 않으므로 패킷을 전송하지 말라는 의미가 된다.  

UDP에서는 ICMP 데이터그램이 클라이언트에게 송신된다.  







